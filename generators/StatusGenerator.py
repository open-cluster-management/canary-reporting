"""SlackGenerator

An AbstractGenerator and ReportGenerator implementation to generate a slack message JSON payload as part of the canary reporting CLI.  
This class can generate its CLI parser, load args, generate a ResultsAggregator object, and format the output data as a Slack JSON payload. 
"""

import os, sys, json, argparse
from generators import AbstractGenerator,ReportGenerator
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
from datamodel import ResultsAggregator as ra

class StatusGenerator(AbstractGenerator.AbstractGenerator, ReportGenerator.ReportGenerator):


    def __init__(self, results_dirs, ignorelist=[], passing_quality_gate=100, executed_quality_gate=100):
        """Create a SlackGenerator Object, unroll xml files from input, and initialize a ResultsAggregator.  

        Required Arguments:
        results_dirs    -- a list of directories that contain XML files from which to generate an aggregate report

        Keyword Arguments:
        ignorelist  --  a list of dicts contianing "name", "squad", and "owner" keys
        passing_quality_gate    --  a number between 0 and 100 that defines the percentage of tests that must pass to declare success
        executed_quality_gate   --  a number between 0 and 100 that defines the percentage of tests that must be executed to declare success
        """
        self.ignorelist = ignorelist
        self.passing_quality_gate = passing_quality_gate
        self.executed_quality_gate = executed_quality_gate
        self.results_files = []
        for _results_dir in results_dirs:
            _files_list = os.listdir(_results_dir)
            for _f in _files_list:
                _full_path = os.path.join(_results_dir, _f)
                if os.path.isfile(_full_path) and _full_path.endswith('.xml'):
                    self.results_files.append(_full_path)
        self.aggregated_results = ra.ResultsAggregator(files=self.results_files, ignorelist=ignorelist)


    def generate_subparser(subparser):
        """Static method to generate a subparser for the StatusGenerator module.  

        Required Argument:
        subparser -- an argparse.ArgumentParser object to extend with a new subparser.  
        """
        subparser_name = 'st'
        st_parser = subparser.add_parser(subparser_name, parents=[ReportGenerator.ReportGenerator.generate_parent_parser()],
            help="Generate a status, exit with 0 on pass and 1 otherwise.",
            formatter_class=argparse.RawTextHelpFormatter,
            epilog="""
Example Usages:

    Generate a status code from test xml base on pass/fail.  
        python3 reporter.py st junit_xml/
""")
        st_parser.set_defaults(func=StatusGenerator.generate_status_from_args)
        return subparser_name, st_parser


    def generate_status_from_args(args):
        """Static method to create a StatusGenerator object and generate a slack report from the command-line args.

        Required Argument:
        args -- argparse-generated arguments from an argparse with a parser generated by StatusGenerator.generate_subparser()
        """
        _ignorelist = []
        if args.ignore_list is not None and os.path.isfile(args.ignore_list):
            try:
                with open(args.ignore_list, "r+") as f:
                    _il = json.loads(f.read())
                _ignorelist = _il['ignored_tests']
            except json.JSONDecodeError as ex:
                print(f"Ignorelist found in {args.ignore_list} was not in JSON format, ignoring the ignorelist. Ironic.")
        _generator = StatusGenerator(args.results_directory, executed_quality_gate=int(args.executed_quality_gate), passing_quality_gate=int(args.passing_quality_gate), ignorelist=_ignorelist)
        exit(_generator.generate_status())

    
    def generate_status(self):
        """Macro function to generate a status given our xml test results - will return a 0 if passing, 1 otherwise"""
        _coverage = self.aggregated_results.get_coverage()
        print("##### Canary Status Report")
        print(f"Expected Percentage Executed: {self.executed_quality_gate}")
        print(f"Actual Percentage Executed: {round(_coverage[ra.ResultsAggregator.skipped], 2)}")
        print(f"Expected Percentage Passed: {self.passing_quality_gate}")
        print(f"Actual Percentage Passed: {round(_coverage[ra.ResultsAggregator.passed], 2)}")
        if _coverage[ra.ResultsAggregator.skipped] < self.executed_quality_gate or _coverage[ra.ResultsAggregator.passed] < self.passing_quality_gate:
            print("##### Result: Failed")
            return 1
        print("##### Result: Passed")
        return 0

